                        Курсовая работа №3

Делаем свой Instagram с едой, котами и еще раз едой!

Эта курсовая потребует знания HTML, Flask, Jinja  и, конечно же, Python.

                        Описание проекта
- **Лента**
    
    Список всех постов. У каждого выводится автор, укороченный до 50 символов текст, количество просмотров , ссылка, которая ведет на пост. 
    
    В шапочке ссылка флажок – ссылка на закладки.

- **Подробный пост**
        
    Страничка с подробной информацией про пост. 
    
    Фото, текст поста и карточка автора берутся из данных поста.
    
    Комментарии берутся из файла с комментариями.
    
    Ссылка "назад" ведет на главную

- **Поиск**    
    
    Форма поиска, отправляется по нажатию на Enter. После нее – результаты поиска.

- **Все посты пользователя**
    
    Посты выбранного пользователя по порядку
    
    Кнопка "назад" ведет на главную

- **Все посты пользователя**
    
    Посты выбранного пользователя по порядку
    
    Кнопка "назад" ведет на главную

# Основная часть

### Шаг подготовительный

Создаем список постов, картинки, шаблоны HTML и CSS-стили.

Переложим шаблоны в папку `templates`.

Переложим стили и картинки в папку `static`.

Обратите внимание: данные хранятся раздельно. Посты вместе с информацией об авторе и его аватаркой хранятся в файле `posts.json`, а комментарии хранятся в файле `comments.json`. Также создан файл `bookmarks.json`, где можно будет хранить закладки.

У каждого поста указаны:

`poster_name` — имя/юзернейм автора поста,

`poster_avatar` — аватарка автора поста,

`pic` — картинка поста,

`content` — текст поста,

`views_count` — количество просмотров,

`likes_count` — количество лайков,

`pk` — id или номер поста.

Обратите внимание, количество комментариев не указано!

У каждого комментария указаны:

`post_id` – к какому посту этот комментарий

`commenter_name` – имя комментатора

`comment` – текст комментария

`pk` – идентификатор (номер) комментарий

### Шаг 0 – подготовим необходимые функции

Прежде, чем приступать к написанию Flask-приложения, полезно разработать функции, для работы с данными и сложить их в отдельном файле, например, `utils.py.` Например:

`get_posts_all()` – возвращает посты

`get_posts_by_user(user_name)` – возвращает посты определенного пользователя. Функция должна вызывать ошибку `ValueError` если такого пользователя нет и пустой список, если у пользователя нет постов.

`get_comments_by_post_id(post_id)` – возвращает комментарии определенного поста. Функция должна вызывать ошибку `ValueError` если такого поста нет и пустой список, если у поста нет комментов. 

`search_for_posts(query)` – возвращает список постов по ключевому слову

`get_post_by_pk(pk)` – возвращает один пост по его идентификатору. 

Напишем к каждой функции юнит тесты, расположите тесты в отдельной папке `/tests`.

Организуем тесты в виде классов или функций, на ваше усмотрение.

### Шаг 1 – реализуйте ленту

Создадим представление для всех постов, это должна быть главная страница.

`GET` `/` 

В нем должно показываться столько постов, сколько есть. Найдите и используйте подходящий шаблон. Замените в каждом шаблоне пути к файлу стилей и картинкам. Замените их на /`static/img` и `/static/css` соответственно!

### Шаг 2 – реализуем просмотр поста

Создаем представление для одного поста 

`GET /posts/<postid>` 

Получим комментарии из файла `comments.json`, у которых соответствующий `postid`.

Выведем комментарии к посту.

### Шаг 3 – реализуем поиск

Создадим представление для поиска по маршруту `GET /search/?s=...` 

В нем должно отображаться 10 постов, если есть. 

Поиск должен выполняться по вхождению ключевого слова в текст поста. Регистрозависимость на ваше усмотрение. 

Найдем и используем подходящий шаблон для вывода результатов. 

### Шаг 4 – Реализуем вывод по пользователю

Создадим представление с выводом постов конкретного пользователя `GET /users/<username>`. Выведите те посты у которых poster name соответствует `username` из запроса. Используйте шаблон `user-feed`

### Шаг 5 – Добавим обработчики ошибок

Добавим обработчик запросов к несуществующим страницам, например `/meow` и верните в этом случае статус-код 404.

Добавим обработчик ошибок, возникших на стороне сервера (ошибка 500, Internal Server Error ) и верните в этом случае статус-код 500.

### Шаг 6 – сделаем 2 API - эндпоинта

Создадим представление, которое обрабатывает запрос `GET /api/posts` и возвращает полный список постов в виде JSON-списка.

Создадим представление, которое обрабатывает запрос `GET /api/posts/<post_id>` и возвращает один пост в виде JSON-словаря.

### Шаг 7 – залогируем обращения к эндпоинтам API

Используя стандартный logging, логи должны храниться в папке logs в файле `api.log` 

### Шаг 8 – добавим тест на API

Протестируем эндпоинт `GET /api/posts` , проверьте, что

- возвращается список
- у элементов есть нужные ключи

Протестируем эндпоинт `GET /api/posts/<post_id>` , проверьте, что

- возвращается словарь
- у элемента есть нужные ключи

### Шаг 8 - опубликуем проект

**Выложим свой проект на GitHub**



